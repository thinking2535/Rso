< Transaction 및 Commit 방식 >
 1. 소켓 외부에서 두 노드 A, B 간 원자적 통신 방법 ( 이 방식은 두개 이상의 노드간에도 마찬가지 )
 	- A에서 B로 전달시작했다는 내용을 메모리 상으로만 세팅(A에서 중복 전달하지 않기 위함) -Begin-하고 B로 내용 전달
		- 여기서 A가 재시작 하면 A는 또다시 B로 전달
	- B에서 Begin 후 Commit (DB저장 등) 후 처리 후 A에 전달// 여기서 Commit 은 중복해서 처리 되지 않도록 해야 함.
	- A에서 -Commit(DB 저장등 마무리)-




* 메모리 부족으로 할당에러나면 처리방법?
 1. 해당 할당에 대헤서만 에러 처리되도록 하고 프로그램 유지 (유력)
	장 : 나머지 유저들에 대해서 접속 끊이 않고 살아있도록 처리
 	단 : 유지된 이후에도 불안한 상태 계속됨

 2. 모든 유저 끊어버림, 또는 catch 하지 않고, 프로세스 죽도록 처리
	장 : 코드 간단
	단 : 메모리 한계 시점에 다시 초기화 되어버림.


* 함수내에서 에러 처리 방법
 1. 모든 체크 후 처리 ( 유력 )
 - 현 함수 내에서의 또다른 함수의 호출 결과는 롤백할 수 없음을 원칙으로 한다.
 - 현 함수 내에서의 또다른 함수의 호출시 에러가 발생할지 체크하는 함수를 두어 체크를 한다.
 - 모든 체크가 통과 된 경우 모든 함수 호출 및 로직 처리
 ? 체크함수가 노출되지 않은 흠수도 있고, 매 함수마다 체크함수를 두는것은 비효율적? => 에러를 반환하는 처리함수를 1개만 둔다. <<<<<<<<<<<<<<<<

 2. 에러시 롤백
 ? Send, DBQuery 등은 롤백할 수 없으므로 롤백 매커니즘의 한계


* 구조체 이름은 아래와 같이 접미사로 구분되도록
Server		Net(Client)	Db			Base
Char		CharCl		CharDb		CharBs
Item		ItemCl		ItemDb		ItemBs


< 프로그래밍 순서 >
1. 객체(변수)의 위치를 정한다.
2. 정해진 변수에 따라 함수를 정한다.
3. 변할 수 있는 것은 명확히 파악하여 변수로( 설정파일? ) 뽑을 것.


< 코딩 >
* 중복코드를 제거할 때는 중복코드를 한 곳으로 이동하여 단순화 하지말고(코드 이해가 어려워지므로)
  함수로 뽑아서 코드를 줄일것.!!!!!!!!!!!!!!!!!!!!
* 최적화는 나중에 할것 ( 병합 분리 등의 작업을 초기에 하면 잦은 변화에 적응하기 힘들며, 코드 수정이 어렵다. 사용되지 않는 것이 있더라도 종류별로 균등하게 나누어 작업할것 )
* 객체의 멤버 변수는 클래스간 ( 포함관계에 있는 클래스 간에도, 수평적인 클래스 간에도 ) 공유하지 않는다.


캐스팅 연산자 사용 준수
C 스타일의 타입 캐스팅을 사용하는 경우에는 타입 캐스팅 오류를 검출하기 어렵다. 캐스팅 연산자는 컴파일러가 타입 캐스팅을 체크하므로 사전에 오류를 검출할 수 있다.
표 6-1 캐스팅 연산자 
캐스팅 연산자  설명  
static_cast<>  호환 가능한 타입간의 타입 캐스팅을 수행하는 연산자  
reinterpret_cast<>  연관성이 없는 포인터 타입을 캐스팅하기 위해 사용  
dynamic_cast<>  안전한 다운 캐스팅을 위한 연산자로 코드 실행 중에 캐스팅을 수행  
const_cast<>  포인터 또는 참조형의 상수성과 휘발성(volatile)을 제거하는 연산자  



< 포인터와 인덱스 >
* 클래스 변수는 포인터가 아닌 인덱스로 보관하여 클라와 공유 가능하고, 객체 복사가 가능하도록 설계할것.
* 포인터는 함수 파라미터에 사용하여 인덱스에서 객체를 구하는 연산비용을 줄일 수 있도록 할것.
* 내부를 감추기 위해선 파라미터는 인덱스로? ( 포인터로 할 경우 내부 액세스 할 수 있게 되므로 -속도가보장될경우, 또는 상관없을 경우- )


< 리스트 동적, 정적 선택 기준 >
* 크기가 실행타임에 정해지고 이후 재할당이 없는 경우	동적(가변) 할당
* 크기가 실행타임에 정해지는 경우			동적(고정) 할당
* 크기가 컴파일타임에 정해지는 경우			정적 할당 ( 복사가능 )




< 객체 구조, 전역, 지역 >
* 전역변수를 포함하는 클래스의 객체는 Globals.h 에 들어갈 수 없다.( Globals.h에는 서로간에 종속성이 없는 전역 객체들만 포함 가능하다 ),
전역변수를 포함하면서 전역인 객체는 해당 객체를 사용할 Global~~.CPP파일에 해당객체, 헤더파일을 둘것

* 메인계층의 cpp, h 파일을 두어 메인파일이 비대해지는것을 방지
* Globals.h 에는 define, enum, struct, typedef 등과, 전역함수 헤더와 extern 변수를 두고, Globals.cpp에는 객체와, 함수의 정의를 둔다.
* 메인계층 h 파일은 Globals.h 를 포함하고, 메인파일은 Globals.h 를 포함하지 않는다.
* 메인cpp는 헤더를 가지지 않으며 메인계층의 cpp파일은 h파일도 가지며, 메인cpp가 그 헤더파일을 포함한다.
* FuncCore 류의 함수는( 혹은 반환값이 void 인 함수는 ) 파라미터를 포인터로 받아서 오류상황을 없앨 수 있도록 한다.
* 공통을 찾기 어려운 경우 추상화는 나중에 신경쓸것.
* 자료형의 상속관계는 교차되지 않도록 하여 중복을 피할것. ( 단, 네트웍 패킷등 구조체로 인한 교차 발생시는 Get함수를 통해서 해당 객체를 얻을것. )
** 분류된 두 클래스를 다중 상속 받아서는 안된다. 왜냐하면 분류된 두 클래스는 서로 공통되는 멤버가 있을 수 있기 때문이다.
( 멤버 함수는 골라 쓰면 된다고 쳐도 멤버 변수는 데이터를 중복 소유하기 때문에 피애야 한다. )
예를 들면
		사람
	어른		아이
위 클래스에서 어른클래스 아이클래스는 서로 사람클래스가 가지는 멤버변수, 멤버함수를 각각 가지고 있기 때문에 다중상속 해서는 안된다.
그렇다면 다중상속이 가능한 경우는? 서로 공통부분이 없는 두 클래스를 다중상속 할 수 있다.


* 부모클래스에서 virtual 함수를 호출할 수 있으려면, override 된 함수에서 부모의 변수를 수정하는 일이 없어야 한다. (부모가 호출한 함수의 내용을 모르므로 자신의 어떤 변수를 어떻게 수정할지 부모가 모름)
  -> override 된 함수 내에서는 super::VirtualFunction() 을 호출하고, 다음 자식의 변수에 액세스 하는 것은 상관 없음.

* 다중상속을 하려면 상속하려하는 두 클래스는 완전히 별개로 컴파일이 되어야 한다.
 ( CRsoNetServer, CRsoNetAsync 는 완전히 분리 시킬 수 있다. 분리는 힘들지 몰라도, 분리되고나면 이후 관리가 용이하다. )
 - 이를 지킬 수 없다면 virtual class 로 중복 제거된 다중상속 할것? ( RsoNet 같은 경우 Sync, Async 클래스 의 관계는 virtual 함수가 들어간 관계라서 분리시키기가 힘들다( 불가능? )그러므로 구현 상속이 필요한데
  그렇다면 virtual class 를 사용할 수 밖에...   그렇다면 virtal 함수를 애초에 사용하지 않는 방법은??  virtual 함수가 없더라도, 밀접한 관계의 두 클래스는 완전히 분리시키기는 어렵고, 합치면 중복이 심해지고,
   그럼 virtual class 가 답인듯 싶은데... 속도가 2배정도 느림,
그래도 전체 프로세스 타임에 비하면 새발에 피 이므로 무시해도 좋을듯 보이는데... )



*** (고민중)속성 변수는 중복이 되더라도 해당 객체에 두는 것이 해당 객체가 변경될 때 객체의 속성이 변경됨을 알 수 있어 속성변경에 종속된 처리를 할 수 있다. ( 정말 그런가? 아니면 옵저버 패턴이 최고 인가? )
 (예) 마블온라인에서 지역의 이벤트 속성 변수는 CRoom::EventRgnNum 으로 하는 것 보다 CRgnGameInfo::bEvent 로 하여 CRgnGameInfo 가 변할때 해당 객체의 bEvent 상태에 따라 처리가 용이하다.
      왜냐하면 CRgnGmaeInfo 에 속한 변수를 한눈에 알 수 있기때문에... 만일 CRoom 에 둔다면 CRgnGameInfo 가 변경되었을 때 CRoom::EventRgnNum 를 고려해야 하는지 놓지기 쉽다.
      단점은? 만일 CRgnGameInfo의 생성자로 초기화 된다면? 어떻게 상태변화처리를 해야 하나? ( CRgnGameInfo::SetEvent() 등이 있다면 가능하겠으나 생성자와 어떻게 결합시킬것인가? )

* 클라이언트가 호출하는 함수명은 다르게 하여 보안 검사를 철저히 하도록.



< Critical Section >
* CS는 중첩 Lock 을 피한다. ( 중첩하지 않고 모든것을 설계할 수 있다? )




< 로직 >
* 로직클래스를 코어로 둘 경우 패킷처리를 외부에서 하기 위한방법
  1. Callback 함수로 패킷 Send 처리 ( 패킷처리하는 class 는 로직 코어를 상속 )
     그렇다면 클라가 가질 클래스는 서버에서 개개 유저의 클래스로?
     어떻게 클라가 필요로하는 로직클래스를 서버에서도 사용할 수 있는가?




< Enum >
* 코딩중 특정한 값이 노출(특정값을 반환하는 등) 되는 일이 없고, 특수연산(비트연산등)이 필요하다면 일반 변수( 또는 클래스 )로 하는게 낫다.
  --> 해당값이 코드에 드러나지 않아야 자유도가 높다,( 기획변경으로 코드변경이 필요 없는 ) 