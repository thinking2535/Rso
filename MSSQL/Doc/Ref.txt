* Async Call //////////////////////////////////////////////////////////////////////////////////////////////////////
 // kkkk
 //SQLULEN Var = SQL_ASYNC_ENABLE_ON;
 //Ret = SQLSetConnectOption(_hDBC, SQL_ATTR_ASYNC_ENABLE, Var );
 //if( Ret != SQL_SUCCESS )
 //{
 // _SqlLog( _hDBC, NULL );
 // if( Ret != SQL_SUCCESS_WITH_INFO )
 // return Exit();
 //}

 //Ret = SQLSetConnectOption(_hDBC, SQL_ATTR_ASYNC_STMT_EVENT, Var );
 //if( Ret != SQL_SUCCESS )
 //{
 // _SqlLog( _hDBC, NULL );
 // if( Ret != SQL_SUCCESS_WITH_INFO )
 // return Exit();
 //}

 //Ret = SQLSetConnectAttr(_hDBC, SQL_ATTR_ASYNC_ENABLE, (void *)SQL_ASYNC_ENABLE_ON, 0);
 //if( Ret != SQL_SUCCESS )
 //{
 // _SqlLog( _hDBC, NULL );
 // if( Ret != SQL_SUCCESS_WITH_INFO )
 // return Exit();
 //}

 //Ret = SQLSetConnectAttr(_hDBC, SQL_ATTR_ASYNC_DBC_FUNCTIONS_ENABLE, (void *)SQL_ASYNC_DBC_ENABLE_ON, 0);
 //if( Ret != SQL_SUCCESS )
 //{
 // _SqlLog( _hDBC, NULL );
 // if( Ret != SQL_SUCCESS_WITH_INFO )
 // return Exit();
 //}

 //////////

 // 2개 이상의 Adhoc 쿼리를 트랜잭션으로 처리해야 할 경우에 주석풀고 수동으로 SQLEndTran 해야 할듯.
 //Ret = SQLSetConnectAttr(_hDBC, SQL_ATTR_AUTOCOMMIT, (SQLPOINTER)SQL_AUTOCOMMIT_OFF, SQL_IS_UINTEGER );
 //if( Ret != SQL_SUCCESS )
 //{
 // _SqlLog( _hDBC, NULL );
 // if( Ret != SQL_SUCCESS_WITH_INFO )
 // return Exit();
 //}










 // kkkk
 // SQLUINTEGER fFuncs;
 // Ret = SQLGetInfo(_hDBC, SQL_MAX_ASYNC_CONCURRENT_STATEMENTS, (SQLPOINTER)&fFuncs,
 //           sizeof(fFuncs),
 //           NULL);
 //
 // Ret = SQLGetInfo(_hDBC, SQL_ASYNC_MODE, (SQLPOINTER)&fFuncs,
 //           sizeof(fFuncs),
 //           NULL);
 // 
 // Ret = SQLGetInfo(_hDBC, SQL_MAX_CONCURRENT_ACTIVITIES, (SQLPOINTER)&fFuncs,
 //           sizeof(fFuncs),
 //           NULL);
 //
 //
 // // SUBSTRING supported
 //if (fFuncs & SQL_FN_STR_SUBSTRING) 
 //   ;   // do something
 //
 //// SUBSTRING not supported
 //else
 //   ;   // do something else
 //////////////////



 // kkkk
 //TReturn RRR;
 ////SQL_API_SQLCOMPLETEASYNC
 ////SQL_API_ODBC3_ALL_FUNCTIONS_SIZE
 //typedef TReturn(SQL_API *SQL_ASYNC_NOTIFICATION_CALLBACK)(
 // SQLPOINTER pContex,
 // BOOL fLast);
 ////SQLAsyncNotificationCallback
 //Ret = SQLCompleteAsync(SQL_HANDLE_STMT, _hSTMT, &RRR);


 // kkkk
 //while( (Ret = SQLExecute( _hSTMT )) == SQL_STILL_EXECUTING )
 //{
 //Ret = SQLExecute( _hSTMT );
 //Ret = SQLExecDirect(_hSTMT, L"EXEC spT2", SQL_NTS);   // OK
 // Sleep( 5000 );
 //}
 ///////////



* Async Call END //////////////////////////////////////////////////////////////////////////////////////////////////////









// 분산 트랜잭션 ( TWO PHASE COMMIT )

 A B
 null null
 start null
 start start
 done start
 done done
 null done
 null null

// 각 노드에서의 디비 쿼리는 동시에 하나의 세션으로만 쿼리되도록 보장할것.
// 한번에 한 노드씩 쿼리를 날리는 방식으로 처리하여 어떠한 이유로 트랜잭션이 끊긴경우, 재 기동시 각 노드의 상태만을 보고 어떤상태인지 알 수 있도록 한다.
// (만일 동시에 쿼리 할 경우 쿼리 응답 함수에서 해당 노드의 상태를 저장해서 다른 노드의 응답이 왔을때 다음트랜잭션을 수행할 수 있음. 속도는 이것이 빠르니 상황에 맞게 선택)
// 트랜잭션이 끊긴경우 노드의 미들웨어가 살아있다면 바로 두 노드의 트랜잭션을 롤백하고, 미들웨어가 죽은 경우나, 네트웍이 끊긴경우에는 다음번 적절한 시점에 롤백할것.
// 트랜잭션 쿼리는 아니지만 자원을 사용하는 쿼리의 경우 트랜잭션 상태가 null 이 아닌경우 처리가 안되도록 할것.








 // rso ttt

 // 입력으로 lob 가 있으면
 // bind 시에 ( rso ttt 참조 ) SQL_LEN_DATA_AT_EXEC 등으로 cpVal 에 크기 셋, index 파라미터에는 ParamData 로 받을 Pointer 구분자 입력
 // Execute 시에 99반환
 // ParamData 호출하여 0이 반환될때까지 SQLPutData ( Pointer에 bind 시에 넣었던 구분자 얻어짐 )
 // Fetch 이후 lob GetData 는  일정 버퍼로 cbLeft 가 어떤값이 될때까지  반복적 Get ( 어디다 적어뒀는데...............!!!!!!! )

 //  SQLPOINTER Pointer = NULL;
 //  Ret = m_paConn[ThreadNum_].ParamData( CmdNum_, &Pointer );
 // 
 // 
 //  {
 //  SDateTime N = GetTimeStamp( CTime::GetNow() );
 //  TValueSize Ind = 1024;
 //  char bb[1024] = {};
 //  CopyMemory( bb, &N, sizeof(SDateTime) );
 //  Ret = SQLPutData(
 //  m_paConn[ThreadNum_].GetStmt(CmdNum_),
 //  bb,
 //  Ind);               // How much data we can get.
 // 
 // 
 //  SDateTime Now;
 //  TValueSize cbLeft = 0;
 //  TValueSize BufSz = sizeof(SDateTime);
 // 
 //  Ret = SQLGetData( 
 //  m_paConn[ThreadNum_].GetStmt(CmdNum_), 
 //  (UWORD) 1,          // the value of the token is the ordinal. 
 //  SQL_C_BINARY,           // The C-type.
 //  &Now,            // A small buffer. 
 //  BufSz,    // The size of the buffer.
 //  &cbLeft);               // How much data we can get.
 //  }



 // rso ttt
 //TReturn CCmd::ParamData( SQLPOINTER* pPointer_ )
 //{
 // TReturn Ret = SQLParamData( _hStmt, pPointer_ );
 // if( Ret != SQL_SUCCESS  &&  Ret != SQL_NO_DATA )
 // _ErrorLogFunc( _hStmt );

 // return Ret;
 //}



 // rso ttt
 //  pParamInfo->pBlock[0].cbVal = SQL_LEN_DATA_AT_EXEC(1);
 //  Ret = SQLBindParameter( _hStmt, (1), GetSqlParam(pParamInfo->pBlock[0].ParamType),
 //  GetCType(pParamInfo->pBlock[0].Type), GetSqlType(pParamInfo->pBlock[0].Type), 1024, 0,
 //  (SQLPOINTER)1, 0, &pParamInfo->pBlock[0].cbVal );
 //  if( Ret != SQL_SUCCESS ) return Ret;




